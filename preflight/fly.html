<!DOCTYPE html>
<meta charset="utf-8">
<style>

path {
  stroke-linecap: butt;
}

.origin {
  pointer-events: none;
  fill-opacity: 1;
  stroke-width: 1px;
  stroke: #000;
  fill: none;
}

.target {
  pointer-events: none;
  fill-opacity: 0.6;
  stroke-width: 1px;
  stroke: #000;
  fill: none;
}
</style>
<svg width="960" height="500">
</svg>
<script src="../node_modules/d3-polygon/build/d3-polygon.js"></script>
<script src="../build/partials.js"></script>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script>

var N = 3,
    data,
    polygons,
    width = 960,
    centroid,
    height = 500,
    count = 0;

var vertices = d3.range(N).map(function(d, i) {
  return [Math.random() * width, Math.random() * height];
});

c1 = d3_polygon.polygonCentroid(vertices);
data = partials.rectangle2Square(partials.triangle2Rectangle(vertices));
c2 = d3_polygon.polygonCentroid(data.square);

var color = d3.scale.category10();

var svg = d3.select("svg").append("g");

var line = d3.svg.line()
            .x(function(d) { return d[0]; })
            .y(function(d) { return d[1]; })
            .interpolate("linear-closed");          

var figure = svg.append("g").attr("class", "collection")
                  .attr("transform", translate([width/2 - c1[0], height/2 - c1[1]]))
                  .selectAll("g")
                  .data(data.map(function(d) {
                    var c = d.centroid();
                    return partials.polygon(d.slice()).translate([-c[0], -c[1]]);
                  }));

var translation = figure
                  .enter().append("g").attr("class", "translation")

var rotation = translation.append("g").attr("class", "rotation");

rotation.append("path")
  .style("fill", function(d, i) { return color(i); })
  .attr("class", "origin")
  .attr("d", line);

figure.each(function(d, i) {
  var a, b;
  a = data[i].centroid();
  b = data[i].origin().centroid();
  d.transform = {
    centroid: a,
    rotation: 0,
    translate: [b[0] - a[0], b[1] - a[1]],
    rotate: data[i].rotation()
  };
});

figure.each(fly);

function fly(_, i) {
  var that = this, C, T, R, variance = i * 250;
        
  C = _.transform.centroid;
  T = _.transform.translate;
  R = _.transform.rotation;

  // rigid translation
  d3.select(this).transition()
      .duration(function(d, j) { return variance + 1000})
      .ease("cubic")
      .attrTween("transform", function(d) {
        var origin, target;

        origin = translate(C);
        target = translate([C[0] + T[0], C[1] + T[1]]);

        return d3.interpolateString(origin, target);
      })
    .each("end", function(d, i) {
      count++;
      if (count == data.length) {
        count = 0;
        figure.each(fly);
      }
    });

  // rigid rotation about polygon centroid
  d3.select(this).select(".rotation").transition()
    .duration(function(d, j) { return variance + 1000})
    .ease("circle")
    .attrTween("transform", function(d) {
      var origin, target;

      origin = rotate(R);
      target = rotate(R + d.transform.rotate);

      return d3.interpolateString(origin, target);
    })

  // cache transform to undo rigid translation and rotation
  _.transform.centroid = [C[0] + T[0], C[1] + T[1]];
  _.transform.translate = [-_.transform.translate[0], -_.transform.translate[1]]
  _.transform.rotation = R + _.transform.rotate;
  _.transform.rotate = -_.transform.rotate;
}

// SVG translation string
function translate(T) {
  return "translate(" + T[0] + " " + T[1] + ")";
}

// SVG rotation string
function rotate(angle) {
  return "rotate(" + angle + ")";
}

</script>