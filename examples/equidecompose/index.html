<!DOCTYPE html>
<meta charset="utf-8">
<style>

.figure {
  fill-opacity: 0.6;
  stroke-width: 1px;
  stroke: none;
}

.subject,.source {
  fill: none;
  stroke-width: 1px;
  stroke: #ababab;
}

</style>
<body>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://d3js.org/d3-polygon.v1.min.js"></script>
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="../../build/d3-equidecompose.js"></script>
<script>

var svg,
    voronoi,
    width = 960,
    height = 500,
    color,
    N = 4,
    sourceVertices, subjectVertices,
    sourceCentroid, subjectCentroid,
    source, subject,
    decomposition,
    count = 0;

color = d3.scale.category10();

// Random Delaunay triangulation
sourceVertices = d3.range(N).map(function(d) {
  return [width / 3 * Math.random(), Math.random() * height];
});

// Random Delaunay triangulation to be scaled
subjectVertices = d3.range(N).map(function(d) {
  return [width / 3 * Math.random(), Math.random() * height];
});

A = d3.geom.delaunay(sourceVertices).map(function(d) { return d; });
B = d3.geom.delaunay(subjectVertices).map(function(d) { return d; });

sourceCentroid = collectionCentroid(A);
subjectCentroid = collectionCentroid(B);

A = translateCollection(A, sub([width / 4, height / 2], sourceCentroid));
B = translateCollection(B, sub([3 * width / 4, height / 2], subjectCentroid));

decomposition = d3.equidecomposeMesh(A, B);

source = decomposition.source();
subject = decomposition.subject();

svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

line = d3.svg.line()
            .x(function(d) { return d[0]; })
            .y(function(d) { return d[1]; })
            .interpolate("linearClosed");   

svg.selectAll(".source")
    .data(source.map(function(d) { return "M" + d.join("L") + "Z"; }), String)
  .enter().append("path")
    .attr("class", "source")
    .attr("d", String);

svg.selectAll(".subject")
    .data(subject.map(function(d) { return "M" + d.join("L") + "Z"; }), String)
  .enter().append("path")
    .attr("class", "subject")
    .attr("d", String);

// Cache translation and rotation about centroid for each polygon.
figure = svg.selectAll("polygon")
            .data(source.map(transformed));

// nest translation under group to hold entire collection of polygons
translation = figure.enter().append("g")
                    .attr("class", "translation")
                    .attr("transform", function(d) {return translate(d.transform.centroid)});                    

// nest rotation under translation group (with a rigid translation)
rotation = translation.append("g").attr("class", "rotation");

rotation.append("path")
  .style("fill", function(d, i) { return color(i); })
  .attr("class", "figure")
  .attr("d", line);

// looping tween of polygons from target position to orignal shape
figure.transition()
      .delay(function(d, i) {return i * Math.round(5000 / source.length) + 100})
      .each(tween);
      
function tween(_, i) {
  var that = this, C, T, R;
        
  C = _.transform.centroid;
  T = _.transform.translate;
  R = _.transform.rotation;

  // rigid translation
  d3.select(this).transition()
      .duration(300)
      .ease("circle")
      .attrTween("transform", function(d) {
        var origin, target;

        originString = translate(C);
        targetString = translate([C[0] + T[0], C[1] + T[1]]);

        return d3.interpolateString(originString, targetString);
      })
      .each("end", function(d, i) {
        count++;
        if (count === source.length) {
          count = 0;
          figure.transition()
                .delay(function(d, i) {return i * Math.round(5000 / source.length) + 100})
                .each(tween);
        }
      });

  // rigid rotation about polygon centroid, nested under translation group
  d3.select(this).select(".rotation").transition()
    .duration(300)
    .ease("circle")
    .attrTween("transform", function(d) {
      var originString, targetString;

      originString = rotate(R);
      targetString = rotate(R + d.transform.rotate);

      return d3.interpolateString(originString, targetString);
    })
  // cache transform (translation and rotation about centroid) to reverse this tween
  _.transform.centroid = [C[0] + T[0], C[1] + T[1]];
  _.transform.translate = [-T[0], -T[1]]
  _.transform.rotation = R - _.transform.rotate;
  _.transform.rotate = -_.transform.rotate;
}

function transformed(d, i) {
  var centroid, target, direction, theta, centeredSubject;

  d = clockwise(d);

  centroid = d3.polygonCentroid(d);
  target = d3.polygonCentroid(subject[i]);
  centeredSubject = translatePolygon(clone(subject[i]), scale(-1, target));
  d = translatePolygon(clone(d), scale(-1, centroid));
  direction = cross([0, 0], d[0], centeredSubject[0])[2] > 0 ? 1 : -1;
  theta = -1 * direction * degree(angle([0, 0], d[0], centeredSubject[0]));
                
  d.transform = {
    centroid: centroid,
    rotation: 0,
    translate: [target[0] - centroid[0], target[1] - centroid[1]],
    rotate: theta
  };

  return d;
}

// SVG translation string
function translate(T) {
  return "translate(" + T[0] + " " + T[1] + ")";
}

// SVG rotation string
function rotate(angle) {
  return "rotate(" + angle + ")";
}

function pairwise(a, b, operation){
  var res = [], i;

  for(i = 0; i < a.length; i++){
    res[i] = operation(a[i], b[i]);
  }
  
  return res;
}

function add(a, b) {
  return pairwise(a, b, function(x, y){
      return x + y;
  });
} 

function sub(a, b) {
  return pairwise(a, b, function(x, y){
    return x - y;
  });
}

function dot(a, b) {
  var res = 0.0, i;

  if (a.length != b.length){
    throw new Error("Invalid dimensions for dot product.");
  }

  for (i = 0; i < a.length; i++) {
    res += a[i] * b[i]; 
  }

  return res;
}

function scale(s, a) {
  return [s * a[0], s * a[1]];
}

function length(u) {
  return Math.sqrt(dot(u, u));
}

function normalize(a) {
  return scale(1 / length(a), a);
}

function cross(a, b, c) {
  var u, v, z, res;

  u = normalize([b[0] - a[0], b[1] - a[1]]),
  v = normalize([c[0] - a[0], c[1] - a[1]]),
  z = u[0] * v[1] - u[1] * v[0],
  res = [0, 0, 0];
  res[0] = res[1] = 0;
  res[2] = z;

  return res;
}

function angle(a, b, c) {
  var u = normalize([b[0] - a[0], b[1] - a[1]]),
      v = normalize([c[0] - a[0], c[1] - a[1]]);

  if ((length(u) * length(v)) == 0) return 0;

  return Math.acos(dot(u, v));
}

function degree(rad) {
  return rad * 180 / Math.PI;
}

function clone(P) {
  var positions = JSON.parse(JSON.stringify(P.slice(0)));
  return Object.assign(positions, P);
}

function translatePolygon(P, T) {
  var i, v, n;
  for (i = 0, n = P.length; i < n; i++) {
    v = P[i];
    P[i] = [v[0] + T[0], v[1] + T[1]];
  }

  return P;
}

function right(point, edge) {
  return cross(point, edge[0], edge[1])[2] < 0;
}

function clockwise(P) {
  var C = d3.polygonCentroid(P);
  if (!right(C, P.slice(0, 2))) P.reverse();
  return P;
}

function collectionCentroid(collection) {
  var centroids;

  centroids = collection.map(function(d) {
    return d3.polygonCentroid(d);
  });

  if (centroids.length == 1) {
    return centroids[0];
  }

  if (centroids.length == 2) {
    return [(centroids[0][0] + centroids[1][0]) / 2,
            (centroids[0][1] + centroids[1][1]) / 2];
  }
  
  return d3.polygonCentroid(centroids);
}

function translateCollection(collection, T) {
  var C = collectionCentroid(collection);
  collection.forEach(function(d) {
    translatePolygon(d, T);
  });
  return collection;
}
</script>